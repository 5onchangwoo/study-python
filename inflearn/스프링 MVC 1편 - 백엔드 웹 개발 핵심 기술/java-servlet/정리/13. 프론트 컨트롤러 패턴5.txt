유연한 컨트롤러1
현재는 컨트롤러의 형태가 고정되어 있다.
다양한 버전의 컨트롤러를 사용하고 싶다면 어댑터 패턴을 적용시켜주어야 한다.

───────────────────────────────────────────────────────────────────────────────────────────
#### 어댑터 패턴 ####
지금까지 프론트컨트롤러는 한가지 방식의 컨트롤러 인터페이스만 사용할 수 있다.
ControllerV3, ControllerV4는 완전히 다른 인터페이스이다.
즉, 서로 호환이 불가능하다.
어댑터 패턴을 사용해서 프론터 컨트롤러가 다양한 방식의 컨트롤러를 처리해보자.

-V5 구조
0. HTTP 요청 [클라이언트 -> FrontController]
1. 핸들러 조회 [FrontController 핸들러 매핑 정보]
2. 핸들러 처리 어댑터 조회 [ FrontController 핸들러 어댑터 목록]
3. handle(handler) [FrontController -> 핸들러 어댑터]
4. handler 호출 [ 핸들러 어댑터 -> 핸들러(컨트롤러) -> 핸들러 어댑터]
5. modelView 반환 [핸들러 어댑터 -> FrontController]
6. viewResolver 호출 [FrontController -> viewResolver]
7. MyView 반환 [FrontController -> FrontController]
8. render(model) 호출 [FrontController -> MyView]
9. HTML 응답 [MyView -> 클라이언트]
% 핸들러 어댑터: 중간에 어댑터 역할을 담당함, 다양한 컨트롤러를 호출해준다.
% 핸들러: 컨트롤러의 이름을 더 넓은 범위의 핸들러로 변경.
         꼭 컨트롤러의 개념 뿐만 아니라 어떤 것이든 해당하는 종류의 어댑터만 있으면 다 처리할 수 있기 때문이다.


#### 실행 로직 ####
handler를 ControllerV4로 캐스팅, paramMap, model을 만들어서 해당 컨트롤러를 호출,
그리고 viewName을 반환 받는다.
어댑터는 이를 MyView에 담아서 반환한다.

#### 어댑터 변환 ####
어댑터가 호출하는 ControllerV4는 뷰의 이름을 반환한다. 그런데 어댑터는 뷰의 이름이 아니라 ModelView를 만들어서 반환한다.
ControllerV4는 뷰의 이름을 반환했지만, 어댑터는 이것을 ModelView로 만들어서 형식을 맞추어 반환한다.


───────────────────────────────────────────────────────────────────────────────────────────
>>>> 정리 <<<<
- 현재까지의 v1 ~ v5에서 추가된 기능
v1 : 프론트 컨트롤러 도입
  * 기존 구조를 최대한 유지하며 프론트 컨트롤러 도입
v2 : View 분류
  * 단순 반복 되는 뷰 로직 분리
v3 : Model 추가
  * 서블릿 종속성 제거
  * 뷰 이름 중복 제거
v4 : 단순하고 실용적인 컨트롤러
  * v3와 거의 비슷
  * 구현하는 입장에서 ModelView를 직접 생성해서 반환하지 않도록
    편리한 인터페이스 제공
v5 : 유연한 컨트롤러
  * 어댑터 도입
  * 어댑터를 추가해서 프레임워크를 유연하고 확장성 있게 설계

- 여기서 더 편리하게 발전시키더라도 어댑터를 이용하면 기존 구조를 유지하면서
  프레임워크의 기능을 확장할 수 있게 된다!


