##### MVC패턴이 나온 이유 #####
1. JSP, 서블릿에 할당된 너무 많은 역할
    하나의 서블릿이나 JSP만으로 비즈니스 로직과 뷰 렌더링까지 모두 처리하고 있어, 너무 많은 역할을 담당하고있다.
    이는 유지보수가 매우 어려워지게 만든다.
    비즈니스 로직을 호출하는 부분에 변경이 발생해도 해당 코드를 손대야 하고, UI를 변경할 일이 있어도
    비즈니스 로직이 함께 있는 해당파일을 수정해야 한다!!

2. 변경된 라이프 사이클
    뷰 렌더링과 비즈니스 로직은 수정하는 시점이 다를 가능성이 매우 높고 대부분은 서로에게 영향을 주지 않는다.
    이런 변경의 라이프 사이클이 다른 부분을 하나의 코드로 관리하는 것은 유지보수 관점에서 매우 좋지 않다.

3. 기능 특화
    JSP같은 뷰 템플릿은 화면을 렌더링 하는데 최적화 되어 있기 떄문에 해당 업무만 담당하는 것이 가장 효과적이다.


### MVC (Model View Controller) ###
- 컨트롤러(Controller): HTTP 요청을 받아서 파라미터를 검증하고, 비즈니스 로직을 실행한다.
    그리고 뷰에 전달할 결과 데이터를 조회해서 '모델'에 담는다.
- 모델(Model): 뷰에 출력할 데이터를 담아둔다. '뷰'가 필요한 데이터를 모두 모델에 담아서 전달해주는 덕분에
    '뷰'는 비즈니스 로직이나 데이터 접근을 몰라도 되고, 화면을 렌더링 하는 일에 집중할 수 있다.
- 뷰(View): 모델에 담겨있는 데이터를 사용해서 화면을 그리는 일에 집중한다.
    예를들어 HTML을 생성하는 부분을 말한다.

-MVC 패턴1.
클라이언트 -(호출)-> 컨트롤러 로직(비즈니스 로직)
                    │
                [모델(데이터)]
                    │
클라이언트 <-(응답)- 뷰 로직


-MVC 패턴2
클라이언트 -(호출)-> 컨트롤러 로직 -> 서비스, 리포지토리(비즈니스 로직 데이터 접근)
                     │
                [모델(데이터)]
                     │
클라이언트 <-(응답)- 뷰 로직

--> 컨트롤러에서 비즈니스로직과 프로그램의 전반적인 컨트롤까지 역할분담이 많아서 그 둘을 분리한 패턴이다.
    비즈니스 로직은 서비스라는 계층을 새롭게 만들어서 따로 관리한다.
───────────────────────────────────────────────────────────────────────────────────────────
##### 구현 TIP! #####
-dispatch.forward(): 다른 서블릿이나 JSP로 이동할 수 있는 기능.
    서버 내부에서 다시 호출이 발생한다. 클라이언트에서는 url가 변하지 않음!

-redirect vs forward: 리다이렉트는 실제 클라이언트(웹 브라우저)에 응답이 나갔다가,
    클라이언트가 redirect 경로로 다시 요청한다. 따라서 클라이언트가 인지할 수 있고
    URL경로도 변경된다.
    하지만 포워드는 서버 내부에서 일어나는 호출이기 때문에 클라이언트가 인지하지 못한다.

-WEB-INF: WAS서버에서 정한 규칙.
         해당 폴더안에 있는 자원들은 무조건 컨트롤러를 통해 호출되어야 한다.

-상대 경로('/'로 시작하지 않음) vs 절대 경로('/'로 시작)
  상대 경로를 사용하면 현재 URL이 속한 계층 경로에 + 된다
  ex) 현재 계층 경로: '/servlet-mvc/members', 경로: 'save'
      결과: '/servlet-mvc/members/save'
      경로가 만약 '/save' 라면 -> 결과는 '/save' 그 자체가 된다.


- jsp에서는 <%= %> 사이에 객체를 불러올 수 있는데
  ((데이터 형)requset.getAttribute("변수 명")).getter 메서드() 이러한 모양으로 나타낼수있다.
  ex) <li>id=<%=((Member)request.getAttribute("member")).getId()%></li>
  JSP에서 이를 편하게 불러올 수 있는 기능을 제공한다
  바로 ${객체명.필드명}와 같은 방법으로 적어주면 된다. (프로퍼티 접근법)
  ex) <li>id=${member.id}</li>
  위의 두개의 예는 같은 기능을 한다.
───────────────────────────────────────────────────────────────────────────────────────────
##### MVC 패턴의 한계 #####
- 포워드 중복
  View로 이동하는 코드가 항상 중복 호출된다.
  (메서드로 공통화 해도 해당 메서드를 항상 직접 호출 해줘야 한다.)
- ViewPath 중복
  prefix:'/WEB-INF/views'
  suffix: '.jsp'
  만약 jsp가 아닌 thymeleaf 같은 다른 뷰 엔진으로 변경하면 전체를 다 변경해야한다.
- 사용하지 않는 코드
  'HttpServletRequest', 'HttpServletResponse'를 사용하지 않는 메서드에서도 작성해야한다.
  (테스트 케이스 작성도 어려움)
- 공통 처리가 어렵다.
  기능이 복잡해질 수록 컨트롤러에서 공통으로 처리해야하는 부분이 많이 증가할것이다.

정리)) 공통 처리가 어렵다.
  해결하기 위해서는 컨트롤러 호철 전에 먼저 공통기능을 처리해야 한다.
  이를 해결하기 위해서 나온 것이 컨트롤러(Front Controller)패턴 이다.
  스프링 MVC의 핵심이 바로 프론트 컨트롤러이다.
───────────────────────────────────────────────────────────────────────────────────────────
